ファクトリーパターンの講義
講義目標
ファクトリーパターンの概念を理解する
ファクトリーパターンの適用シナリオを学ぶ
ファクトリーパターンの実装方法を学ぶ
ファクトリーパターンの利点と欠点を理解する
1. イントロダクション
ファクトリーパターンの概要
定義: ファクトリーパターンは、オブジェクトの生成を専門のファクトリーメソッドに委譲するデザインパターンです。これにより、クラスのインスタンス化をクライアントから隠蔽し、インターフェースを介してオブジェクトを生成することができます。
目的: クラスのインスタンス生成に関する責任をクライアントから分離し、柔軟で再利用可能なコードを作成する。
2. ファクトリーパターンの適用シナリオ
使用例
オブジェクトの生成ロジックをカプセル化: 複雑な生成プロセスをクライアントから隠蔽し、簡単にオブジェクトを生成できるようにする。
製品ファミリの生成: 同じインターフェースを持つ異なる種類のオブジェクトを生成する必要がある場合。
柔軟性の向上: 新しい種類のオブジェクトが追加されたときに、クライアントコードの変更を最小限に抑える。
3. ファクトリーパターンの実装方法
Javaでのファクトリーパターン実装
製品のインターフェース:

java
Copy code
public interface Product {
    void use();
}
具体的な製品クラス:

java
Copy code
public class ConcreteProductA implements Product {
    public void use() {
        System.out.println("Using Product A");
    }
}

public class ConcreteProductB implements Product {
    public void use() {
        System.out.println("Using Product B");
    }
}
ファクトリークラス:

java
Copy code
public class Factory {
    public static Product createProduct(String type) {
        if (type.equals("A")) {
            return new ConcreteProductA();
        } else if (type.equals("B")) {
            return new ConcreteProductB();
        }
        throw new IllegalArgumentException("Unknown product type");
    }
}
使用例:

java
Copy code
public class Main {
    public static void main(String[] args) {
        Product productA = Factory.createProduct("A");
        productA.use();

        Product productB = Factory.createProduct("B");
        productB.use();
    }
}
C#でのファクトリーパターン実装
製品のインターフェース:

csharp
Copy code
public interface IProduct {
    void Use();
}
具体的な製品クラス:

csharp
Copy code
public class ConcreteProductA : IProduct {
    public void Use() {
        Console.WriteLine("Using Product A");
    }
}

public class ConcreteProductB : IProduct {
    public void Use() {
        Console.WriteLine("Using Product B");
    }
}
ファクトリークラス:

csharp
Copy code
public class Factory {
    public static IProduct CreateProduct(string type) {
        if (type == "A") {
            return new ConcreteProductA();
        } else if (type == "B") {
            return new ConcreteProductB();
        }
        throw new ArgumentException("Unknown product type");
    }
}
使用例:

csharp
Copy code
public class Program {
    public static void Main(string[] args) {
        IProduct productA = Factory.CreateProduct("A");
        productA.Use();

        IProduct productB = Factory.CreateProduct("B");
        productB.Use();
    }
}
4. ファクトリーパターンの利点と欠点
利点
柔軟性: 新しい製品タイプを追加する際に、既存のクライアントコードを変更する必要がない。
カプセル化: オブジェクトの生成ロジックをクライアントから隠蔽する。
再利用性: ファクトリーメソッドを通じてオブジェクトの生成ロジックを再利用できる。
欠点
複雑性の増加: クラス階層とインターフェースの数が増えるため、設計が複雑になる可能性がある。
クラスの追加: ファクトリークラスやインターフェースなど、追加のクラスが必要になる。
5. 実際のファクトリーパターンの使用例
Unityでのファクトリーパターンの使用例
製品のインターフェース:

csharp
Copy code
public interface IEnemy {
    void Attack();
}
具体的な製品クラス:

csharp
Copy code
public class Orc : IEnemy {
    public void Attack() {
        Debug.Log("Orc attacks!");
    }
}

public class Troll : IEnemy {
    public void Attack() {
        Debug.Log("Troll attacks!");
    }
}
ファクトリークラス:

csharp
Copy code
public class EnemyFactory {
    public static IEnemy CreateEnemy(string type) {
        switch (type) {
            case "Orc":
                return new Orc();
            case "Troll":
                return new Troll();
            default:
                throw new ArgumentException("Unknown enemy type");
        }
    }
}
使用例:

csharp
Copy code
public class GameManager : MonoBehaviour {
    void Start() {
        IEnemy orc = EnemyFactory.CreateEnemy("Orc");
        orc.Attack();

        IEnemy troll = EnemyFactory.CreateEnemy("Troll");
        troll.Attack();
    }
}
まとめと質疑応答
まとめ:

ファクトリーパターンの定義と目的を復習
ファクトリーパターンの適用シナリオを確認
ファクトリーパターンの実装方法を理解
ファクトリーパターンの利点と欠点を再確認
質疑応答:

学生からの質問に答える
ファクトリーパターンの具体的な使用例や問題点についてディスカッション
まとめ
ファクトリーパターンは、オブジェクトの生成を専門のファクトリーメソッドに委譲することで、クライアントから生成ロジックを隠蔽し、柔軟で再利用可能なコードを作成するためのデザインパターンです。このパターンを正しく使用することで、アプリケーションの設計が柔軟かつ拡張性のあるものになりますが、誤用すると複雑性が増加する可能性があります。この授業を通じて、ファクトリーパターンの正しい使い方とその限界を理解し、適切な場面で効果的に活用できるようになります。







ファクトリーパターンの基本原理
オブジェクトの生成をファクトリーメソッドに委ねる利点
実践:

csharp
Copy code
public abstract class Enemy
{
    public abstract void Attack();
}

public class Goblin : Enemy
{
    public override void Attack() { Debug.Log("Goblin attacks!"); }
}

public class Troll : Enemy
{
    public override void Attack() { Debug.Log("Troll attacks!"); }
}

public class EnemyFactory
{
    public static Enemy CreateEnemy(string type)
    {
        switch (type)
        {
            case "Goblin":
                return new Goblin();
            case "Troll":
                return new Troll();
            default:
                throw new ArgumentException("Unknown enemy type");
        }
    }
}
ファクトリーパターンを使用して、異なるタイプの敵キャラクターを生成



