シングルトンパターンの講義
講義目標
シングルトンパターンの概念を理解する
シングルトンパターンの適用シナリオを学ぶ
シングルトンパターンの実装方法を学ぶ
シングルトンパターンの利点と欠点を理解する
1. イントロダクション
シングルトンパターンの概要
定義: シングルトンパターンは、特定のクラスのインスタンスが一つしか存在しないことを保証するデザインパターンです。
目的: グローバルなアクセス点を提供し、インスタンスの数を制限する。
2. シングルトンパターンの適用シナリオ
使用例
設定管理: アプリケーション全体で共有される設定情報を管理する。
ログ管理: ログファイルへのアクセスを集中管理する。
データベース接続: アプリケーション全体で共有されるデータベース接続を管理する。
3. シングルトンパターンの実装方法
Javaでのシングルトンパターン実装
シンプルなシングルトン実装:

java
Copy code
public class Singleton {
    private static Singleton instance;

    private Singleton() {
        // プライベートコンストラクタ
    }

    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
スレッドセーフなシングルトン実装:

java
Copy code
public class Singleton {
    private static volatile Singleton instance;

    private Singleton() {
        // プライベートコンストラクタ
    }

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
C#でのシングルトンパターン実装
シンプルなシングルトン実装:

csharp
Copy code
public class Singleton {
    private static Singleton instance;

    private Singleton() {
        // プライベートコンストラクタ
    }

    public static Singleton Instance {
        get {
            if (instance == null) {
                instance = new Singleton();
            }
            return instance;
        }
    }
}
スレッドセーフなシングルトン実装:

csharp
Copy code
public class Singleton {
    private static readonly object lockObject = new object();
    private static Singleton instance;

    private Singleton() {
        // プライベートコンストラクタ
    }

    public static Singleton Instance {
        get {
            if (instance == null) {
                lock (lockObject) {
                    if (instance == null) {
                        instance = new Singleton();
                    }
                }
            }
            return instance;
        }
    }
}
4. シングルトンパターンの利点と欠点
利点
一貫性: 一つのインスタンスのみが存在するため、一貫した状態を維持できます。
グローバルアクセス: グローバルなアクセス点を提供するため、複数のコンポーネントが同じインスタンスにアクセスできます。
欠点
テストの難しさ: グローバルな状態を持つため、ユニットテストが難しくなる場合があります。
柔軟性の欠如: シングルトンはインスタンスの数を制限するため、柔軟性が低下する可能性があります。
密結合: シングルトンはグローバルな状態を持つため、システム全体が密結合になるリスクがあります。
5. 実際のシングルトンパターンの使用例
Unityでのシングルトンパターンの使用例
シンプルなシングルトン実装:

csharp
Copy code
using UnityEngine;

public class GameManager : MonoBehaviour {
    private static GameManager instance;

    public static GameManager Instance {
        get {
            if (instance == null) {
                instance = FindObjectOfType<GameManager>();

                if (instance == null) {
                    GameObject singletonObject = new GameObject();
                    instance = singletonObject.AddComponent<GameManager>();
                    singletonObject.name = typeof(GameManager).ToString() + " (Singleton)";
                }
            }
            return instance;
        }
    }

    private void Awake() {
        if (instance == null) {
            instance = this;
            DontDestroyOnLoad(gameObject);
        } else {
            Destroy(gameObject);
        }
    }
}
まとめと質疑応答
まとめ:

シングルトンパターンの定義と目的を復習
シングルトンパターンの適用シナリオを確認
シングルトンパターンの実装方法を理解
シングルトンパターンの利点と欠点を再確認
質疑応答:

学生からの質問に答える
シングルトンパターンの具体的な使用例や問題点についてディスカッション
まとめ
シングルトンパターンは、特定のクラスのインスタンスが一つしか存在しないことを保証するためのデザインパターンです。正しく使用することで、アプリケーションの設計がシンプルで一貫性のあるものになりますが、誤用すると柔軟性が低下し、テストが難しくなる可能性があります。この授業を通じて、シングルトンパターンの正しい使い方とその限界を理解し、適切な場面で効果的に活用できるようになります。











# シングルトンパターンの原理とユースケース
シングルトンパターンのメリットとデメリット
実践:

csharp
Copy code
public class GameManager : MonoBehaviour
{
    private static GameManager instance;

    public static GameManager Instance
    {
        get
        {
            if (instance == null)
            {
                instance = FindObjectOfType<GameManager>();
                if (instance == null)
                {
                    GameObject go = new GameObject("GameManager");
                    instance = go.AddComponent<GameManager>();
                }
            }
            return instance;
        }
    }

    void Awake()
    {
        if (instance == null)
        {
            instance = this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }
}
シングルトンを使用して、ゲーム全体で共通のゲームマネージャーを管理
ファクトリーパターン
















