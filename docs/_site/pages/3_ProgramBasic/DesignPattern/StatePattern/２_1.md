ステートパターンをUnityで使用する方法として以下２つを取り上げます
+ ジェネリックを使用する方法
+ Animation ControllerでStateMachineBehaviourを使用する方法


ステートパターンは、オブジェクトがその内部状態に応じて異なる動作をするためのデザインパターンです。


# ジェネリックを使用したステートパターン


<br>

State.cs
```cs

namespace StatePattern_Generic
{
    public abstract class State<T>
    {
        protected T Owner;

        public State(T owner)
        {
            Owner = owner;
        }

        public abstract void Enter();
        public abstract void Update();
        public abstract void Exit();
    }
}


```
<br>

StateMachine.cs
```cs

using System.Collections.Generic;

namespace StatePattern_Generic
{
    public class StateMachine<T>
    {
        private T _owner;
        private State<T> _currentState;
        private Dictionary<System.Type, State<T>> _states = new Dictionary<System.Type, State<T>>();

        public StateMachine(T owner)
        {
            _owner = owner;
        }

        public void AddState(State<T> state)
        {
            var type = state.GetType();
            if (!_states.ContainsKey(type))
            {
                _states[type] = state;
            }
        }

        public void ChangeState<S>() where S : State<T>
        {
            if (_currentState != null)
            {
                _currentState.Exit();
            }

            var type = typeof(S);
            if (_states.ContainsKey(type))
            {
                _currentState = _states[type];
                _currentState.Enter();
            }
        }

        public void Update()
        {
            if (_currentState != null)
            {
                _currentState.Update();
            }
        }
    }
}



```

<br>

Player.cs
```cs

using UnityEngine;

namespace StatePattern_Generic
{
    public class Player : MonoBehaviour
    {
        private StateMachine<Player> _stateMachine;

        void Start()
        {
            _stateMachine = new StateMachine<Player>(this);
            _stateMachine.AddState(new PlayerIdleState(this));
            _stateMachine.AddState(new PlayerMoveState(this));

            _stateMachine.ChangeState<PlayerIdleState>();
        }

        void Update()
        {
            _stateMachine.Update();
        }

        public void ChangeState<S>() where S : State<Player>
        {
            _stateMachine.ChangeState<S>();
        }
    }
}


```
<br>

PlayerIdleState.cs

```cs
using UnityEngine;

namespace StatePattern_Generic
{
    public class PlayerIdleState : State<Player>
    {
        public PlayerIdleState(Player owner) : base(owner) { }

        public override void Enter()
        {
            Debug.Log("Player Entering Idle State");
        }

        public override void Update()
        {
            if (Input.GetKeyDown(KeyCode.Space))
            {
                Owner.GetComponent<Player>().ChangeState<PlayerMoveState>();
            }
        }

        public override void Exit()
        {
            Debug.Log("Player Exiting Idle State");
        }
    }
}


```


<br>

PlayerMoveState.cs
```cs
using UnityEngine;

namespace StatePattern_Generic
{
    public class PlayerMoveState : State<Player>
    {
        public PlayerMoveState(Player owner) : base(owner) { }

        public override void Enter()
        {
            Debug.Log("Player Entering Move State");
        }

        public override void Update()
        {
            Owner.transform.Translate(Vector3.forward * Time.deltaTime);

            if (Input.GetKeyUp(KeyCode.Space))
            {
                Owner.GetComponent<Player>().ChangeState<PlayerIdleState>();
            }
        }

        public override void Exit()
        {
            Debug.Log("Player Exiting Move State");
        }
    }
}


```
<br>

Enemy.cs

```cs


using UnityEngine;

namespace StatePattern_Generic
{
    public class Enemy : MonoBehaviour
    {
        private StateMachine<Enemy> _stateMachine;

        void Start()
        {
            _stateMachine = new StateMachine<Enemy>(this);
            _stateMachine.AddState(new EnemyIdleState(this));
            _stateMachine.AddState(new EnemyMoveState(this));

            _stateMachine.ChangeState<EnemyIdleState>();
        }

        void Update()
        {
            _stateMachine.Update();
        }

        public void ChangeState<S>() where S : State<Enemy>
        {
            _stateMachine.ChangeState<S>();
        }
    }
}


```

<br>

EnemyIdleState.cs
```cs

namespace StatePattern_Generic
{
    public class EnemyIdleState : State<Enemy>
    {
        public EnemyIdleState(Enemy owner) : base(owner) { }

        public override void Enter()
        {
            Debug.Log("Enemy Entering Idle State");
        }

        public override void Update()
        {
            // 敵のIdleロジック
            if (Random.Range(0, 100) < 5)
            {
                Owner.GetComponent<Enemy>().ChangeState<EnemyMoveState>();
            }
        }

        public override void Exit()
        {
            Debug.Log("Enemy Exiting Idle State");
        }
    }
}



```
<br>

EnemyMoveState.cs
```cs

namespace StatePattern_Generic
{
    public class EnemyMoveState : State<Enemy>
    {
        public EnemyMoveState(Enemy owner) : base(owner) { }

        public override void Enter()
        {
            Debug.Log("Enemy Entering Move State");
        }

        public override void Update()
        {
            Owner.transform.Translate(Vector3.forward * Time.deltaTime);

            // 偶然の確率でIdle状態に戻る
            if (Random.Range(0, 100) < 5)
            {
                Owner.GetComponent<Enemy>().ChangeState<EnemyIdleState>();
            }
        }

        public override void Exit()
        {
            Debug.Log("Enemy Exiting Move State");
        }
    }
}



```


「Player.cs」「各Stateクラス」どちらにChangeStateメソッドの呼び出しを書くかは、設計の好みや具体的なシナリオに依存しますが、一般的なアプローチは次の通りです。

* Player.csに書く場合:

Playerクラスがキー入力を監視し、状態遷移を直接制御します。
簡潔でシンプルな場合に適しています。

* 各Stateクラスに書く場合:

ステートが自分自身で次の状態を決定し、Playerクラスがそれを意識しないようにします。  
よりモジュール化されていて、ステートの切り替えロジックが各ステートに閉じ込められます。  
より複雑な状態遷移ロジックに適しています。


<br>



# Animation ControllerでStateMachineBehaviourを使用した例


UnityエディタでAnimator Controllerを作成します。
Idle と Move の2つのステートを追加。

StateMachineBehaviourのアタッチ:
* Idle ステートに IdleStateBehaviour.cs をアタッチします。
* Move ステートに MoveStateBehaviour.cs をアタッチします。


トランジションの設定:
* Idle ステートから Move ステートへのトランジションを作成し、トリガー Move を設定します。
* Move ステートから Idle ステートへのトランジションを作成し、トリガー Idle を設定します。

<br>

IdleStateBehaviour.cs

```cs

using UnityEngine;

namespace StatePattern_AnimationController
{
    public class IdleStateBehaviour : StateMachineBehaviour
    {
        override public void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
        {
            Debug.Log("Entering Idle State");
        }

        override public void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
        {
            // Idle state logic
        }

        override public void OnStateExit(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
        {
            Debug.Log("Exiting Idle State");
        }
    }
}


```


<br>

MoveStateBehaviour.cs

```cs

using UnityEngine;

namespace StatePattern_AnimationController
{
    public class MoveStateBehaviour : StateMachineBehaviour
    {
        override public void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
        {
            Debug.Log("Entering Move State");
        }

        override public void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
        {
            // Move state logic
            var player = animator.GetComponent<PlayerAnimatorController>();
            if (player != null)
            {
                player.transform.Translate(Vector3.forward * Time.deltaTime);
            }
        }

        override public void OnStateExit(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
        {
            Debug.Log("Exiting Move State");
        }
    }
}


```

<br>

PlayerAnimatorController.cs

```cs

using UnityEngine;

namespace StatePattern_AnimationController
{
    public class PlayerAnimatorController : MonoBehaviour
    {
        private Animator _animator;

        void Start()
        {
            _animator = GetComponent<Animator>();
        }

        void Update()
        {
            if (Input.GetKeyDown(KeyCode.Space))
            {
                _animator.SetTrigger("Move");
            }

            if (Input.GetKeyUp(KeyCode.Space))
            {
                _animator.SetTrigger("Idle");
            }
        }
    }
}


```